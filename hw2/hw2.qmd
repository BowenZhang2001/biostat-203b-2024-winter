---
title: "Biostat 203B Homework 2"
subtitle: Due Feb 9 @ 11:59PM
author: "Bowen Zhang  UID:506126821"
format:
  html:
    theme: cosmo
    embed-resources: true
    number-sections: false
    toc: true
    toc-depth: 4
    toc-location: left
    code-fold: false
knitr:
  opts_chunk: 
    cache: false    
    echo: true
    fig.align: 'center'
    fig.width: 6
    fig.height: 4
    message: FALSE
execute:
  eval: false    
---

Display machine information for reproducibility:
```{r}
#| eval: true

sessionInfo()
```

Load necessary libraries (you can add more as needed).
```{r setup}
#| eval: true

library(arrow)
library(data.table)
library(memuse)
library(pryr)
library(R.utils)
library(tidyverse)
```

Display memory information of your computer
```{r}
#| eval: true

memuse::Sys.meminfo()
```

In this exercise, we explore various tools for ingesting the [MIMIC-IV](https://mimic.mit.edu/docs/iv/) data introduced in [homework 1](https://ucla-biostat-203b.github.io/2024winter/hw/hw1/hw1.html).

Display the contents of MIMIC `hosp` and `icu` data folders:

```{bash}
#| eval: true

ls -l ~/mimic/hosp/
```

```{bash}
#| eval: true

ls -l ~/mimic/icu/
```

## Q1. `read.csv` (base R) vs `read_csv` (tidyverse) vs `fread` (data.table)

### Q1.1 Speed, memory, and data types

There are quite a few utilities in R for reading plain text data files. Let us test the speed of reading a moderate sized compressed csv file, `admissions.csv.gz`, by three functions: `read.csv` in base R, `read_csv` in tidyverse, and `fread` in the data.table package.

Which function is fastest? Is there difference in the (default) parsed data types? How much memory does each resultant dataframe or tibble use? (Hint: `system.time` measures run times; `pryr::object_size` measures memory usage.)

**Answer: **

```{r}
#| eval: true

# Read data using read.csv in base R
system.time({
  admissions <- read.csv("~/mimic/hosp/admissions.csv.gz")
})

pryr::object_size(admissions)

admissions |> head(width = Inf)
```

```{r}
#| eval: true

# Read data using read_csv in tidyverse
system.time({
  admissions <- read_csv("~/mimic/hosp/admissions.csv.gz")
})

pryr::object_size(admissions)

admissions |> head(width = Inf)
```

```{r}
#| eval: true

# Read data using fread in data.table
system.time({
  admissions <- fread("~/mimic/hosp/admissions.csv.gz")
})

pryr::object_size(admissions)

admissions |> head(width = Inf)
```
`fread()` is the fastest, and `read.csv()` is the slowest among those three functions.

The default parsed data types are different. 

For baseR `read.csv()` uses `int` for all integers and uses `chr` for all other columns including characters and time.

For yidyverse `read_csv()` uses `dbl` for all numerical columns, uses `chr` for characters and uses `S3: POSIXct` for dates and times.

For data.table `fread()` uses `int` for all integers, uses `chr` for characters, and uses `S3: POSIXct` for dates and times.

The memory usage of `read.csv()` is 159 MB, the memory usage of `read_csv()` is 55 MB, and the memory usage of `fread()` is 50 MB.

### Q1.2 User-supplied data types

Re-ingest `admissions.csv.gz` by indicating appropriate column data types in `read_csv`. Does the run time change? How much memory does the result tibble use? (Hint: `col_types` argument in `read_csv`.)

**Answer: **

```{r}
#| eval: true

system.time({
  admissions <- read_csv("~/mimic/hosp/admissions.csv.gz",
                         col_types = 'iiTTTfcffffffTTf')
})

pryr::object_size(admissions)

admissions |> head(width = Inf)

rm(admissions)
```
After changing some character columns to factors, the memory usage of the result tibble is 38 MB, which is the less than the default data types. The run time is 1.5 seconds, which is also shorter than the default data types.

## Q2. Ingest big data files

Let us focus on a bigger file, `labevents.csv.gz`, which is about 125x bigger than `admissions.csv.gz`.
```{bash}
#| eval: true

ls -l ~/mimic/hosp/labevents.csv.gz
```
Display the first 10 lines of this file.
```{bash}
#| eval: true

zcat < ~/mimic/hosp/labevents.csv.gz | head -10
```

### Q2.1 Ingest `labevents.csv.gz` by `read_csv`

Try to ingest `labevents.csv.gz` using `read_csv`. What happens? If it takes more than 5 minutes on your computer, then abort the program and report your findings. 

**Answer: **
```{r}
#| eval: false

# DON'T RUN THIS CODE

# rm(list = ls())

# Read data using read_csv in tidyverse
# system.time({
#   labevents <- read_csv("~/mimic/hosp/labevents.csv.gz")
# })

# pypryr::object_size(labevents)
```

It takes more than 5 minutes on my laptop, and it crashed after that. The following is the screenshot of the error message. When trying to ingest the data, the memory usage of RStudio increases rapidly, and is over 7GB in the red circle in the screenshot. Then the RStudio crashes.
![crash](./crash.jpg)

### Q2.2 Ingest selected columns of `labevents.csv.gz` by `read_csv`

Try to ingest only columns `subject_id`, `itemid`, `charttime`, and `valuenum` in `labevents.csv.gz` using `read_csv`.  Does this solve the ingestion issue? (Hint: `col_select` argument in `read_csv`.)

**Answer: **
```{r}
#| eval: false

# DON'T RUN THIS CODE

# system.time({
#   labevents <- read_csv("~/mimic/hosp/labevents.csv.gz",
#                         col_select = c("subject_id",
#                                        "itemid",
#                                        "charttime",
#                                        "valuenum"))
# })

# pypr::object_size(labevents)
```
This does not solve the problem. It also takes more than 5 minutes, so I abort the program.

### Q2.3 Ingest subset of `labevents.csv.gz`

Our first strategy to handle this big data file is to make a subset of the `labevents` data.  Read the [MIMIC documentation](https://mimic.mit.edu/docs/iv/modules/hosp/labevents/) for the content in data file `labevents.csv`.

In later exercises, we will only be interested in the following lab items: creatinine (50912), potassium (50971), sodium (50983), chloride (50902), bicarbonate (50882), hematocrit (51221), white blood cell count (51301), and glucose (50931) and the following columns: `subject_id`, `itemid`, `charttime`, `valuenum`. Write a Bash command to extract these columns and rows from `labevents.csv.gz` and save the result to a new file `labevents_filtered.csv.gz` in the current working directory. (Hint: use `zcat <` to pipe the output of `labevents.csv.gz` to `awk` and then to `gzip` to compress the output. To save render time, put `#| eval: false` at the beginning of this code chunk.)

Display the first 10 lines of the new file `labevents_filtered.csv.gz`. How many lines are in this new file? How long does it take `read_csv` to ingest `labevents_filtered.csv.gz`?

**Answer: **
```{bash}
#| eval: false

# DON'T RUN THIS CODE
# Extract the required columns and rows from labevents.csv.gz
zcat < ~/mimic/hosp/labevents.csv.gz | \
awk -F, 'BEGIN{OFS = ","} {
  if ($5 == 50912 || $5 == 50971 || $5 == 50983 || $5 == 50902 ||
      $5 == 50882 || $5 == 51221 || $5 == 51301 || $5 == 50931)
  {
    print $2,$5,$7,$10
  }
}' | gzip > labevents_filtered.csv.gz

```

```{bash}
#| eval: true

# Display the first 10 lines of the new file labevents_filtered.csv.gz
zcat < labevents_filtered.csv.gz | head -10
```

```{bash}
#| eval: true

# Show how many lines in this file
zcat < labevents_filtered.csv.gz | wc -l
```

```{r}
#| eval: true
# use read_csv() to ingest labevents_filtered.csv.gz
system.time({
  lab_filtered <- read_csv("labevents_filtered.csv.gz",
                           col_names = c('subject_id', 'itemid',
                                         'charttime',' valuenum'))
})

rm(lab_filtered)
```
There are 24855909 lines in this file. It takes 10 seconds to ingest the file.

### Q2.4 Ingest `labevents.csv` by Apache Arrow

Our second strategy is to use [Apache Arrow](https://arrow.apache.org/) for larger-than-memory data analytics. Unfortunately Arrow does not work with gz files directly. First decompress `labevents.csv.gz` to `labevents.csv` and put it in the current working directory. To save render time, put `#| eval: false` at the beginning of this code chunk.

Then use [`arrow::open_dataset`](https://arrow.apache.org/docs/r/reference/open_dataset.html) to ingest `labevents.csv`, select columns, and filter `itemid` as in Q2.3. How long does the ingest+select+filter process take? Display the number of rows and the first 10 rows of the result tibble, and make sure they match those in Q2.3. (Hint: use `dplyr` verbs for selecting columns and filtering rows.)

Write a few sentences to explain what is Apache Arrow. Imagine you want to explain it to a layman in an elevator. 

**Answer: **
```{bash}
#| eval: false

# DON'T RUN THIS CODE
# Decompress labevents.csv.gz to labevents.csv
# zcat < ~/mimic/hosp/labevents.csv.gz > labevents.csv
```

```{r}
#| eval: true

# use arrow to ingest labevents.csv
system.time({
  lab_arrow <- arrow::open_dataset("labevents.csv", format = 'csv') |>
    dplyr::select(subject_id, itemid, charttime, valuenum) %>%
    dplyr::filter(itemid %in% c(50912, 50971, 50983, 50902,
                                50882, 51221, 51301, 50931))
})

```
```{r}
#| eval: true

# Display the number of rows and the first 10 rows of the result tibble
nrow(lab_arrow)
lab_arrow |> collect() |> head(10)

rm(lab_arrow)
```
Ingest+select+filter process takes 0.08 seconds. The number of rows and the first 10 rows of the result tibble match those in Q2.3.


Apache Arrow is like a universal translator for data in the world of computers. It provides a standardized way to represent complex data structures in memory, and a common language for programs to exchange data with each other. It makes it possible for different programs to understand each other's data without having to convert it back and forth between different formats. This makes it easier to write programs that work with data from different sources, and to combine data from different programs into a single analysis.

### Q2.5 Compress `labevents.csv` to Parquet format and ingest/select/filter

Re-write the csv file `labevents.csv` in the binary Parquet format (Hint: [`arrow::write_dataset`](https://arrow.apache.org/docs/r/reference/write_dataset.html).) How large is the Parquet file(s)? How long does the ingest+select+filter process of the Parquet file(s) take? Display the number of rows and the first 10 rows of the result tibble and make sure they match those in Q2.3. (Hint: use `dplyr` verbs for selecting columns and filtering rows.)

Write a few sentences to explain what is the Parquet format. Imagine you want to explain it to a layman in an elevator.

**Answer: **
```{r}
#| eval: false

# write labevents.csv to Parquet format
lab_arrow <- arrow::open_dataset("labevents.csv", format = 'csv')
arrow::write_dataset(lab_arrow, "labevents.parquet", format = c('parquet'))
```

```{r}
#| eval: true

# check the size of the Parquet file

file.info("labevents.parquet/part-0.parquet")$size / 1024^3
```

```{r}
#| eval: true

# use arrow to ingest labevents.parquet
system.time({
  lab_parquet <- arrow::open_dataset("labevents.parquet", format = 'parquet') |>
    dplyr::select(subject_id, itemid, charttime, valuenum) %>%
    dplyr::filter(itemid %in% c(50912, 50971, 50983, 50902,
                                50882, 51221, 51301, 50931))
})
```

```{r}
#| eval: true

# Display the number of rows and the first 10 rows of the result tibble
nrow(lab_parquet)
lab_parquet |> collect() |> head(10) 

rm(lab_parquet)
```

The parquet file is 1.93 GB. The ingest+select+filter process of the Parquet file takes 0.3 seconds. The number of rows and the first 10 rows of the result tibble match those in Q2.3.

Parquet is a file format for storing data. It packs data together in a smart way, making it lightning-fast for computers to read and process. It is designed to work well with distributed computing systems like Hadoop and Spark. Parquet files are organized into a columnar format, which means that each column of data is stored separately, making it easy to read and write only the data that is needed for a particular analysis.

### Q2.6 DuckDB

Ingest the Parquet file, convert it to a DuckDB table by [`arrow::to_duckdb`](https://arrow.apache.org/docs/r/reference/to_duckdb.html), select columns, and filter rows as in Q2.5. How long does the ingest+convert+select+filter process take? Display the number of rows and the first 10 rows of the result tibble and make sure they match those in Q2.3. (Hint: use `dplyr` verbs for selecting columns and filtering rows.)

Write a few sentences to explain what is DuckDB. Imagine you want to explain it to a layman in an elevator.

**Answer: **
```{r}
#| eval: true

# use arrow to convert labevents.parquet to DuckDB table
system.time({
  lab_duckdb <- arrow::open_dataset("labevents.parquet", format = 'parquet') |>
    arrow::to_duckdb(table = "lab_duckdb") |>
    dplyr::select(subject_id, itemid, charttime, valuenum) |>
    dplyr::filter(itemid %in% c(50912, 50971, 50983, 50902,
                                50882, 51221, 51301, 50931))
})
```

```{r}
#| eval: true

# Display the number of rows and the first 10 rows of the result tibble
lab_duckdb |> collect() |> nrow()
lab_duckdb |> collect() |> head(10) 
```
```{r}
#| eval: true

# Show lab_duckdb sorted by subject_id in ascending order,
# and print the first ten rows.
lab_duckdb |> collect() |> arrange(subject_id) |> head(10)

rm(lab_duckdb)
```
ingest+convert+select+filter process takes aounrd 1 second. The number of rows matches those in Q2.3. However, the first 10 rows does not match. If we arrange the result tibble by `subject_id` in ascending order, the first 10 rows match those in Q2.3.

DuckDB is a free, open-source, embedded, in-process, relational, OnLine Analytical Processing, DataBase Management System, that is designed to be fast and efficient for analytical queries. DuckDB is designed to be easy to use, and is designed to work well with the R programming language.


## Q3. Ingest and filter `chartevents.csv.gz`

[`chartevents.csv.gz`](https://mimic.mit.edu/docs/iv/modules/icu/chartevents/) contains all the charted data available for a patient. During their ICU stay, the primary repository of a patientâ€™s information is their electronic chart. The `itemid` variable indicates a single measurement type in the database. The `value` variable is the value measured for `itemid`. The first 10 lines of `chartevents.csv.gz` are
```{bash}
#| eval: true
zcat < ~/mimic/icu/chartevents.csv.gz | head -10
```
[`d_items.csv.gz`](https://mimic.mit.edu/docs/iv/modules/icu/d_items/) is the dictionary for the `itemid` in `chartevents.csv.gz`.
```{bash}
#| eval: true
zcat < ~/mimic/icu/d_items.csv.gz | head -10
```
In later exercises, we are interested in the vitals for ICU patients: heart rate (220045), mean non-invasive blood pressure (220181), systolic non-invasive blood pressure (220179), body temperature in Fahrenheit (223761), and respiratory rate (220210). Retrieve a subset of `chartevents.csv.gz` only containing these items, using the favorite method you learnt in Q2. 

Document the steps and show code. Display the number of rows and the first 10 rows of the result tibble.

**Answer: **

```{bash}
#| eval: false

# DON'T RUN THIS CODE
# Extract the required columns and rows from chartevents.csv.gz
zcat < ~/mimic/icu/chartevents.csv.gz | \
awk -F, 'BEGIN{OFS = ","} {
  if ($7 == 220045 || $7 == 220181 || $7 == 220179 ||
      $7 == 223761 || $7 == 220210)
  {
    print $0
  }
}' | gzip > chartevents_filtered.csv.gz
```

```{r}
#| eval: true

# use read_csv() to ingest chartevents_filtered.csv.gz
chart_filtered <- read_csv("chartevents_filtered.csv.gz",
                           col_names = c('subject_id', 'hadm_id',
                                         'stay_id', 'caregiver_id',
                                         'charttime', 'storetime',
                                         'itemid', 'value',
                                         'valuenum', 'valueuom', 'warning'),
                           col_types = 'iiiiTTicdci')
```

```{r}
#| eval: true

nrow(chart_filtered)
chart_filtered |> head(10)

rm(chart_filtered)
```
I choose the method of Q2.3. I use bash code to extract required rows from `chartevents.csv.gz` and save as `chartevents_filtered.csv.gz`. Then I use `read_csv()` to ingest the filtered dataset. The number of rows is 22502319, and the first 10 rows of the result tibble are displayed.
